import{_ as s,c as a,a2 as e,o as p}from"./chunks/framework.DPDg7N6I.js";const t="/img/js%E5%8E%9F%E5%9E%8B%E9%93%BE.png",u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/javascript/Conclusion.md","filePath":"pages/javascript/Conclusion.md"}'),o={name:"pages/javascript/Conclusion.md"};function l(r,n,i,c,d,h){return p(),a("div",null,n[0]||(n[0]=[e(`<h2 id="css-盒子模型-链接" tabindex="-1">CSS 盒子模型 <a href="https://baike.baidu.com/item/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/9814562?fr=aladdin" target="_blank" rel="noreferrer">链接</a> <a class="header-anchor" href="#css-盒子模型-链接" aria-label="Permalink to &quot;CSS 盒子模型 [链接](https://baike.baidu.com/item/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/9814562?fr=aladdin)&quot;">​</a></h2><p>标准盒模型 content-box 怪异盒模型 border-box</p><p>块级盒子 Block Box &amp; 内联盒子 Inline Box</p><p>块级盒子 Block Box：</p><ul><li>Content box</li><li>Padding box</li><li>Border box</li><li>Margin box</li></ul><p>一个被定义成块级的（block）盒子会表现出以下行为:</p><ul><li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</li><li>每个盒子都会换行</li><li>width 和 height 属性可以发挥作用</li><li>内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”</li></ul><p>如果一个盒子对外显示为 inline，那么他的行为如下:</p><ul><li>盒子不会产生换行。</li><li>width 和 height 属性将不起作用。</li><li>内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。</li></ul><p>display有一个特殊的值，它在内联和块之间提供了一个中间状态。这对于以下情况非常有用:您不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。</p><p>一个元素使用 display: inline-block，实现我们需要的块级的部分效果：</p><ul><li>设置width 和height 属性会生效。</li><li>padding, margin, 以及border 会推开其他元素。</li></ul><ul><li><strong>box-sizing</strong> <a href="http://www.jianshu.com/p/e2eb0d8c9de6" target="_blank" rel="noreferrer">参考</a></li></ul><p><a href="https://www.w3.org/TR/CSS22/box.html" target="_blank" rel="noreferrer">翻墙</a></p><ol><li>content-box：标准盒模型，CSS 定义的宽高只包含 content 的宽高</li><li>border-box：IE 盒模型，CSS 定义的宽高包括了 content，padding 和 border</li></ol><h2 id="javascript-原型与原型链-链接" tabindex="-1">Javascript 原型与原型链 <a href="http://www.jianshu.com/p/dee9f8b14771" target="_blank" rel="noreferrer">链接</a> <a class="header-anchor" href="#javascript-原型与原型链-链接" aria-label="Permalink to &quot;Javascript 原型与原型链 [链接](http://www.jianshu.com/p/dee9f8b14771)&quot;">​</a></h2><h3 id="普通对象和函数对象" tabindex="-1">普通对象和函数对象 <a class="header-anchor" href="#普通对象和函数对象" aria-label="Permalink to &quot;普通对象和函数对象&quot;">​</a></h3><blockquote><p>JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象</p></blockquote><table tabindex="0"><thead><tr><th>普通对象</th><th>函数对象</th></tr></thead><tbody><tr><td>var o1 = {};</td><td>function f1(){};</td></tr><tr><td>var o2 =new Object();</td><td>var f2 = function(){};</td></tr><tr><td>var o3 = new f1();</td><td>var f3 = new Function(&#39;str&#39;,&#39;console.log(str)&#39;);</td></tr></tbody></table><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>console.log(typeof Object); //function</span></span>
<span class="line"><span>console.log(typeof Function); //function</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(typeof f1); //function</span></span>
<span class="line"><span>console.log(typeof f2); //function</span></span>
<span class="line"><span>console.log(typeof f3); //function</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(typeof o1); //object</span></span>
<span class="line"><span>console.log(typeof o2); //object</span></span>
<span class="line"><span>console.log(typeof o3); //object</span></span></code></pre></div><p>o1 o2 o3 为普通对象，f1 f2 f3 为函数对象。 凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。</p><h3 id="构造函数" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数" aria-label="Permalink to &quot;构造函数&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function Person(name, age, job) {</span></span>
<span class="line"><span> this.name = name;</span></span>
<span class="line"><span> this.age = age;</span></span>
<span class="line"><span> this.job = job;</span></span>
<span class="line"><span> this.sayName = function() { alert(this.name) }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var person1 = new Person(&#39;Zaxlct&#39;, 28, &#39;Software Engineer&#39;);</span></span>
<span class="line"><span>var person2 = new Person(&#39;Mick&#39;, 23, &#39;Doctor&#39;);</span></span></code></pre></div><p>person1 和 person2 都是 Person 的实例。这两个实例都有一个 constructor （构造函数）属性，该属性（是一个指针）指向 Person。 即：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  console.log(person1.constructor == Person); //true</span></span>
<span class="line"><span>  console.log(person2.constructor == Person); //true</span></span></code></pre></div><p>我们要记住两个概念（<strong>构造函数，实例</strong>）： person1 和 person2 都是 (构造函数 Person[函数对象]) 的**实例 ** <strong>一个公式</strong>：实例的构造函数属性（constructor）指向构造函数。</p><h3 id="原型对象" tabindex="-1">原型对象 <a class="header-anchor" href="#原型对象" aria-label="Permalink to &quot;原型对象&quot;">​</a></h3><blockquote><p>在 JavaScript 中，每当定义一个对象（<strong>函数也是对象</strong>）时候，对象中都会包含一些预定义的属性。其中每个<strong>函数对象</strong>都有一个<strong>prototype 属性</strong>，这个属性指向函数的<strong>原型对象</strong>。 **公式：**每个对象都有 <strong>proto</strong> 属性，但只有函数对象才有 prototype 属性</p></blockquote><p><img src="`+t+`" alt=""></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function Person() {}</span></span>
<span class="line"><span>Person.prototype.name = &#39;Zaxlct&#39;;</span></span>
<span class="line"><span>Person.prototype.age  = 28;</span></span>
<span class="line"><span>Person.prototype.job  = &#39;Software Engineer&#39;;</span></span>
<span class="line"><span>Person.prototype.sayName = function() {</span></span>
<span class="line"><span>  alert(this.name);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var person1 = new Person();</span></span>
<span class="line"><span>person1.sayName(); // &#39;Zaxlct&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var person2 = new Person();</span></span>
<span class="line"><span>person2.sayName(); // &#39;Zaxlct&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(person1.sayname == person2.sayname); //true</span></span></code></pre></div><p>改写：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Person.prototype = {</span></span>
<span class="line"><span>   name:  &#39;Zaxlct&#39;,</span></span>
<span class="line"><span>   age: 28,</span></span>
<span class="line"><span>   job: &#39;Software Engineer&#39;,</span></span>
<span class="line"><span>   sayName: function() {</span></span>
<span class="line"><span>     alert(this.name);</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><strong>原型对象就是 Person.prototype</strong> 在上面我们给 A 添加了 四个属性：name、age、job、sayName。其实它还有一个默认的属性：<strong>constructor</strong></p><blockquote><p>在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（<strong>Person</strong>）</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Person.prototype.constructor == Person</span></span>
<span class="line"><span>person1.constructor == Person //上边例子中 person1实例</span></span></code></pre></div><p>person1 为什么有 constructor 属性？那是因为 person1 是 Person 的实例。 那 Person.prototype 为什么有 constructor 属性？？同理， Person.prototype （你把它想象成 A） 也是 Person 的实例。 也就是在 Person 创建的时候，创建了一个它的实例对象并赋值给它的 prototype，基本过程如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> var A = new Person();</span></span>
<span class="line"><span> Person.prototype = A;</span></span></code></pre></div><p>**可以理解为：**原型对象（Person.prototype）是 构造函数（Person）的一个实例。 **结论：**高程红宝书说，构造函数的原型对象并不是构造函数的一个实例。只是构造函数的一个属性，这个属性是自动获得的。</p><p>原型对象其实就是普通对象（但 Function.prototype 除外，它是函数对象，但它很特殊，他没有 prototype 属性（前面说道函数对象都有 prototype 属性））。看下面的例子：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function Person(){};</span></span>
<span class="line"><span> console.log(Person.prototype) //Person{}</span></span>
<span class="line"><span> console.log(typeof Person.prototype) //Object</span></span>
<span class="line"><span> console.log(typeof Function.prototype) // Function，这个特殊</span></span>
<span class="line"><span> console.log(typeof Object.prototype) // Object</span></span>
<span class="line"><span> console.log(typeof Function.prototype.prototype) //undefined</span></span></code></pre></div><p>**结论：**所有函数对象的 <strong>proto</strong> 都指向 Function.prototype，它是一个 javascript <strong>native 函数</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>extend: function(Child, Parent) {</span></span>
<span class="line"><span>    function Ctor() {</span></span>
<span class="line"><span>      this.constructor = Child;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    Ctor.prototype = Parent.prototype;</span></span>
<span class="line"><span>    Child.prototype = new Ctor();</span></span>
<span class="line"><span>    Child.super_ = Parent.prototype;</span></span>
<span class="line"><span>  },</span></span></code></pre></div><h2 id="target-和-currenttarget-参考" tabindex="-1">target 和 currentTarget <a href="https://www.cnblogs.com/54td/p/5936816.html" target="_blank" rel="noreferrer">参考</a> <a class="header-anchor" href="#target-和-currenttarget-参考" aria-label="Permalink to &quot;target 和 currentTarget [参考](https://www.cnblogs.com/54td/p/5936816.html)&quot;">​</a></h2><h2 id="dom-hash" tabindex="-1">DOM hash <a class="header-anchor" href="#dom-hash" aria-label="Permalink to &quot;DOM hash&quot;">​</a></h2><p><a href="http://www.w3school.com.cn/jsref/prop_loc_hash.asp" target="_blank" rel="noreferrer">参考 1</a><a href="http://blog.csdn.net/somanygenius/article/details/48000285" target="_blank" rel="noreferrer">参考 2</a></p>`,45)]))}const b=s(o,[["render",l]]);export{u as __pageData,b as default};
