import{_ as a,c as e,a2 as t,o as n}from"./chunks/framework.DPDg7N6I.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/linux/Linux Command.md","filePath":"pages/linux/Linux Command.md"}'),i={name:"pages/linux/Linux Command.md"};function l(o,s,p,r,d,h){return n(),e("div",null,s[0]||(s[0]=[t(`<h2 id="搜索" tabindex="-1">搜索 <a class="header-anchor" href="#搜索" aria-label="Permalink to &quot;搜索&quot;">​</a></h2><table tabindex="0"><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>find .xargs</code> ¦ <code>grep -ri &quot;strname&quot;</code></td><td>搜索当前目录所有文件是否包含某个字符串</td></tr><tr><td><code>netstat -tlnp</code></td><td>查看端口</td></tr><tr><td><code>ln -s a/b /usr/local/bin</code></td><td>添加 b 命令到环境变量</td></tr><tr><td><code>sudo passwd [ username ]</code></td><td>修改 root 和普通用户密码</td></tr></tbody></table><p><a href="http://www.cnblogs.com/mengyan/archive/2012/09/04/2669894.html" target="_blank" rel="noreferrer">环境变量详解</a></p><h2 id="vim" tabindex="-1">Vim <a class="header-anchor" href="#vim" aria-label="Permalink to &quot;Vim&quot;">​</a></h2><ul><li>强制保存</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>:w !sudo tee %</span></span></code></pre></div><h2 id="linux-守护进程-daemon【node-可用-pm2-框架】参考-1-参考-2-阮一峰" tabindex="-1">Linux 守护进程（daemon【node 可用 PM2 框架】<a href="http://www.jb51.net/article/80184.htm" target="_blank" rel="noreferrer">参考 1</a> <a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noreferrer">参考 2 阮一峰</a> <a class="header-anchor" href="#linux-守护进程-daemon【node-可用-pm2-框架】参考-1-参考-2-阮一峰" aria-label="Permalink to &quot;Linux 守护进程（daemon【node 可用 PM2 框架】[参考 1](http://www.jb51.net/article/80184.htm) [参考 2 阮一峰](http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html)&quot;">​</a></h2><blockquote><p>由来： 启动一个基于 node 的简单 http 服务器</p></blockquote><ul><li>脚本代码</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>//server.js</span></span>
<span class="line"><span>var http = require(&#39;http&#39;);</span></span>
<span class="line"><span>http.createServer(function(req, res) {</span></span>
<span class="line"><span> res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});</span></span>
<span class="line"><span> res.end(&#39;Hello World&#39;);</span></span>
<span class="line"><span>}).listen(5000);</span></span></code></pre></div><h3 id="前台任务-foreground-job-与后台任务-background-job" tabindex="-1">前台任务（foreground job）与后台任务（background job） <a class="header-anchor" href="#前台任务-foreground-job-与后台任务-background-job" aria-label="Permalink to &quot;前台任务（foreground job）与后台任务（background job）&quot;">​</a></h3><ul><li>执行以下命令启动脚本</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node server.js</span></span></code></pre></div><p>这样启动的脚本为 “前台任务”，独占命令窗口，运行完成或手动停止，才能执行其他命令。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node server.js &amp;</span></span></code></pre></div><p>这样启动的进程就会成为&quot;后台任务&quot;。如果要让正在运行的&quot;前台任务&quot;变为&quot;后台任务&quot;，可以先按 ctrl + z，然后执行 bg 命令（让最近一个暂停的&quot;后台任务&quot;继续执行）。</p><blockquote><p>后台任务特点</p></blockquote><ul><li>继承当前 session （对话）的标准输出（stdout）和标准错误（stderr）。因此，后台任务的所有输出依然会同步地在命令行下显示。</li><li>不再继承当前 session 的标准输入（stdin）。你无法向这个任务输入指令了。如果它试图读取标准输入，就会暂停执行（halt）。</li></ul><h3 id="sighup-信号" tabindex="-1">SIGHUP 信号 <a class="header-anchor" href="#sighup-信号" aria-label="Permalink to &quot;SIGHUP 信号&quot;">​</a></h3><p>变为&quot;后台任务&quot;后，一个进程是否就成为了守护进程呢？或者说，用户退出 session 以后，&quot;后台任务&quot;是否还会继续执行？ Linux 系统是这样设计的：</p><ol><li>用户准备退出 session</li><li>系统向该 session 发出 SIGHUP 信号</li><li>session 将 SIGHUP 信号发给所有子进程</li><li>子进程收到 SIGHUP 信号后，自动退出</li></ol><p>这就解释了为什么&quot;前台任务&quot;会随着 session 的退出而退出：因为它收到了 SIGHUP 信号。那么，&quot;后台任务&quot;是否也会收到 SIGHUP 信号？ 这由 Shell 的 huponexit 参数决定的。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>shopt | grep huponexit//查看huponexit参数的值。</span></span></code></pre></div><p>大多数 Linux 系统，这个参数默认关闭（off）。因此，session 退出的时候，不会把 SIGHUP 信号发给&quot;后台任务&quot;。所以，一般来说，&quot;后台任务&quot;不会随着 session 一起退出。</p><h3 id="disown-命令" tabindex="-1">disown 命令 <a class="header-anchor" href="#disown-命令" aria-label="Permalink to &quot;disown 命令&quot;">​</a></h3><p>通过&quot;后台任务&quot;启动&quot;守护进程&quot;并不保险，因为有的系统的 huponexit 参数可能是打开的（on）。 更保险的方法是使用 disown 命令。它可以将指定任务从&quot;后台任务&quot;列表（jobs 命令的返回结果）之中移除。一个&quot;后台任务&quot;只要不在这个列表之中，session 就肯定不会向它发出 SIGHUP 信号。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node server.js &amp;</span></span>
<span class="line"><span>disown //移出最近一个正在执行的后台任务 [-r|-a|-h][自行查阅]</span></span></code></pre></div><h2 id="ftp" tabindex="-1">FTP <a class="header-anchor" href="#ftp" aria-label="Permalink to &quot;FTP&quot;">​</a></h2><p><a href="http://wingblog.top:92/" target="_blank" rel="noreferrer">参考</a><a href="https://blog.csdn.net/hitabc141592/article/details/7573950" target="_blank" rel="noreferrer">https://blog.csdn.net/hitabc141592/article/details/7573950</a></p><h2 id="后台运行-守护-screen" tabindex="-1">后台运行 守护 screen <a class="header-anchor" href="#后台运行-守护-screen" aria-label="Permalink to &quot;后台运行 守护 screen&quot;">​</a></h2><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#开启一个任务</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">screen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -S</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 【taskName】·</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Ctrl+A Ctrl+D  保存退出</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#查看所有任务</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">screen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ls</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#重新连接某个任务</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">screen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 【taskName】</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#删除一个任务</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">screen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -S</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 【taskName】</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -X</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> quit</span></span></code></pre></div>`,31)]))}const k=a(i,[["render",l]]);export{u as __pageData,k as default};
